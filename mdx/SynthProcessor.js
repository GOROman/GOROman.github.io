
//import Module from './mdx.wasm.js';
//import WASMAudioBuffer from './util/WASMAudioBuffer.js';

/**
 * Copyright 2019 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


// Basic byte unit of WASM heap. (16 bit = 2 bytes)
const BYTES_PER_UNIT = Uint16Array.BYTES_PER_ELEMENT;

// Byte per audio sample. (32 bit float)
const BYTES_PER_SAMPLE = Float32Array.BYTES_PER_ELEMENT;

// The max audio channel on Chrome is 32.
const MAX_CHANNEL_COUNT = 32;

/**
 * A WASM HEAP wrapper for AudioBuffer class. This breaks down the AudioBuffer
 * into an Array of Float32Array for the convinient WASM opearion.
 *
 * @class
 * @dependency Module A WASM module generated by the emscripten glue code.
 */
class WASMAudioBuffer {
  /**
   * @constructor
   * @param  {object} wasmModule WASM module generated by Emscripten.
   * @param  {number} length Buffer frame length.
   * @param  {number} channelCount Number of channels.
   * @param  {number=} maxChannelCount Maximum number of channels.
   */
  constructor(wasmModule, length, channelCount, maxChannelCount) {
    // The |channelCount| must be greater than 0, and less than or equal to
    // the maximum channel count.
    this._isInitialized = false;
    this._module = wasmModule;
    this._length = length;
    this._maxChannelCount = maxChannelCount
        ? Math.min(maxChannelCount, MAX_CHANNEL_COUNT)
        : channelCount;
    this._channelCount = channelCount;
    this._allocateHeap();
    this._isInitialized = true;
  }

  /**
   * Allocates memory in the WASM heap and set up Float32Array views for the
   * channel data.
   *
   * @private
   */
  _allocateHeap() {
    const channelByteSize = this._length * BYTES_PER_SAMPLE;
    const dataByteSize = this._channelCount * channelByteSize;
    this._dataPtr = this._module._malloc(dataByteSize);
    this._channelData = [];
    for (let i = 0; i < this._channelCount; ++i) {
      let startByteOffset = this._dataPtr + i * channelByteSize;
      let endByteOffset = startByteOffset + channelByteSize;
      // Get the actual array index by dividing the byte offset by 2 bytes.
      this._channelData[i] =
          this._module.HEAPF32.subarray(startByteOffset >> BYTES_PER_UNIT,
                                        endByteOffset >> BYTES_PER_UNIT);
    }
  }

  /**
   * Adapt the current channel count to the new input buffer.
   *
   * @param  {number} newChannelCount The new channel count.
   */
  adaptChannel(newChannelCount) {
    if (newChannelCount < this._maxChannelCount) {
      this._channelCount = newChannelCount;
    }
  }

  /**
   * Getter for the buffer length in frames.
   *
   * @return {?number} Buffer length in frames.
   */
  get length() {
    return this._isInitialized ? this._length : null;
  }

  /**
   * Getter for the number of channels.
   *
   * @return {?number} Buffer length in frames.
   */
  get numberOfChannels() {
    return this._isInitialized ? this._channelCount : null;
  }

  /**
   * Getter for the maxixmum number of channels allowed for the instance.
   *
   * @return {?number} Buffer length in frames.
   */
  get maxChannelCount() {
    return this._isInitialized ? this._maxChannelCount : null;
  }

  /**
   * Returns a Float32Array object for a given channel index. If the channel
   * index is undefined, it returns the reference to the entire array of channel
   * data.
   *
   * @param  {number|undefined} channelIndex Channel index.
   * @return {?Array} a channel data array or an
   * array of channel data.
   */
  getChannelData(channelIndex) {
    if (channelIndex >= this._channelCount) {
      return null;
    }

    return typeof channelIndex === 'undefined'
        ? this._channelData : this._channelData[channelIndex];
  }

  getF32Array() {
    return this._channelData[0];
  }

  /**
   * Returns the base address of the allocated memory space in the WASM heap.
   *
   * @return {number} WASM Heap address.
   */
  getPointer() {
    return this._dataPtr;
  }

  /**
   * Frees the allocated memory space in the WASM heap.
   */
  free() {
    this._isInitialized = false;
    this._module._free(this._dataPtr);
    this._channelData = null;
  }
} // class WASMAudioBuffer

export default WASMAudioBuffer;

// Web Audio API's render block size
const NUM_FRAMES = 128;
var filetype = 'MDX';
var pdxfilename = "bos.pdx";
class SynthProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    // Create an instance of Synthesizer and WASM memory helper. Then set up an
    // event handler for MIDI data from the main thread.
    this._synth = new Module.Synthesizer(sampleRate);

    this._outputBuffer = new WASMAudioBuffer(Module, NUM_FRAMES, 2, 2);
    this.port.onmessage = this.onMessage.bind(this);

    // Channel mute state (bitmask: bit 0-7 = FM 1-8, bit 8-15 = PCM 1-8)
    this._channelMask = 0;

    // MIDI state
    // Bitmask of channels currently controlled by MIDI (bit 0-7 = FM 1-8)
    this._midiChannelActive = 0;
    // MIDI key state for each FM channel
    this._midiKeyState = new Array(8).fill(null).map(() => ({ keyOn: false, note: 0 }));

///    var lookup = FS.lookupPath(".", { parent: true });

  }

  process(inputs, outputs) {

    // Call the render function to fill the WASM buffer. Then clone the
    // rendered data to process() callback's output buffer.
    this._synth.render(this._outputBuffer.getPointer(), NUM_FRAMES);

    for (let i = 0; i < outputs[0].length; i++) {
      outputs[0][i].set(this._outputBuffer.getChannelData(i));
    }

    return true;
  }

  getReg(addr) {
    return this._synth.getReg(addr);
  }

  onMessage(event) {
    //    console.log(event);
    const data = event.data;
//    console.log(data);
  if ( data == "MDX" ) {
    filetype = "MDX";
  } else if ( data == "OPM" ) {
      var str = "";
      for (let y = 0; y < 16; ++y) {
        for (let x = 0; x < 16; ++x) {
          var s = this._synth.getReg(x + y * 16).toString(16).toUpperCase();
          if (s.length == 1) {
            s = "0" + s;
          }
          str += s + " ";
        }
        str += "<br>";
      }
  } else if ( data == "CHANNEL" ) {
      // チャンネルデータをJSON形式で返す
      const channelData = {
        type: "CHANNEL",
        fm: [],
        pcm: [],
        opmRegs: [],
        playTime: this._synth.getPlayTime(),
        loopCount: this._synth.getLoopCount(),
        tempo: this._synth.getTempo(),
        titleBytes: Array.from(this._synth.getTitleBytes()),
        // MIDI state
        midiChannelActive: this._midiChannelActive,
        midiKeyState: this._midiKeyState
      };
      for (let i = 0; i < 8; i++) {
        const keyOnEx = this._synth.getFmKeyOnEx(i);
        channelData.fm.push({
          note: this._synth.getFmNote(i),
          noteBend: this._synth.getFmNoteBend(i),
          volume: this._synth.getFmVolume(i),
          keyOn: keyOnEx.currentKeyOn,
          logicalSumOfKeyOn: keyOnEx.logicalSumOfKeyOn
        });
      }
      for (let i = 0; i < 8; i++) {
        channelData.pcm.push({
          note: this._synth.getPcmNote(i),
          volume: this._synth.getPcmVolume(i),
          keyOn: this._synth.getPcmKeyOn(i),
          logicalSumOfKeyOn: this._synth.getPcmKeyOnLogicalSum(i)
        });
      }
      // OPM Registers (0x00-0xFF)
      for (let i = 0; i < 256; i++) {
        channelData.opmRegs.push(this._synth.getReg(i));
      }
      this.port.postMessage(JSON.stringify(channelData));
      return;
  } else if ( data == "GET_TITLE" ) {
      // Return title immediately
      const titleData = {
        type: "TITLE",
        titleBytes: Array.from(this._synth.getTitleBytes())
      };
      this.port.postMessage(JSON.stringify(titleData));
      return;
  } else if ( data == "STOP" ) {
      this._synth.stop();
      return;
  } else if ( data == "REPLAY" ) {
      console.log("REPLAY command received");
      this._synth.replay();
      return;
  } else if ( data == "FADEOUT" ) {
      this._synth.fadeout();
      return;
  } else if ( typeof data == 'string' && data.startsWith('{') ) {
      // JSON message
      try {
        const msg = JSON.parse(data);
        if (msg.type === 'MUTE') {
          // Update channel mask
          // FM: bit 0-7, PCM: bit 8-15
          const bitPos = msg.channelType === 'fm' ? msg.channel : (msg.channel + 8);
          if (msg.muted) {
            this._channelMask |= (1 << bitPos);
          } else {
            this._channelMask &= ~(1 << bitPos);
          }
          // Apply to synth (MXDRV uses lower 9 bits: FM 0-7 + PCM)
          // Also include MIDI active channels to mute MDX on those channels
          this._synth.setChannelMask((this._channelMask | this._midiChannelActive) & 0x1ff);
          console.log("Channel mask set to:", this._channelMask.toString(16));
        }
        else if (msg.type === 'MIDI_KEY_ON') {
          // MIDI Key On
          const fmCh = msg.midiChannel % 8;
          console.log(`MIDI Key On: MIDI ch=${msg.midiChannel} note=${msg.note} -> FM ch=${fmCh}`);

          // Mark this channel as MIDI-controlled
          this._midiChannelActive |= (1 << fmCh);
          console.log(`MIDI active channels: 0x${this._midiChannelActive.toString(16)}`);

          // Update MIDI key state
          this._midiKeyState[fmCh] = { keyOn: true, note: msg.note };

          // First, send Key Off to stop any MDX sound on this channel
          this._synth.midiKeyOff(fmCh);

          // Send Key On to OPM
          console.log(`Calling midiKeyOn(${fmCh}, ${msg.note})`);
          this._synth.midiKeyOn(fmCh, msg.note);
        }
        else if (msg.type === 'MIDI_KEY_OFF') {
          // MIDI Key Off
          const fmCh = msg.midiChannel % 8;
          const lastNote = this._midiKeyState[fmCh] ? this._midiKeyState[fmCh].note : -1;

          // Only process key off if it matches the last key on note
          if (lastNote !== msg.note) {
            console.log(`MIDI Key Off: MIDI ch=${msg.midiChannel} note=${msg.note} -> FM ch=${fmCh} (ignored: last note was ${lastNote})`);
            return;
          }

          console.log(`MIDI Key Off: MIDI ch=${msg.midiChannel} note=${msg.note} -> FM ch=${fmCh}`);

          // Update MIDI key state (keep channel as MIDI-controlled)
          this._midiKeyState[fmCh] = { keyOn: false, note: msg.note };

          // Send Key Off to OPM
          this._synth.midiKeyOff(fmCh);

          // NOTE: Do NOT clear _midiChannelActive - keep MDX muted on this channel
          // MDX will stay muted until page reload
          console.log(`MIDI active channels (kept): 0x${this._midiChannelActive.toString(16)}`);
        }
      } catch (e) {
        console.error("JSON parse error:", e);
      }
      return;
  } else if ( typeof data == 'string' ) {
    if (data.match( /\.pdx/i )) {
      filetype = "PDX";
      pdxfilename = data;
      console.log("PDX!!:"+pdxfilename);
    }
  } else {

      var a1 = new Uint8Array(data);
      let pointer = Module._malloc(data.byteLength);
      Module.HEAPU8.set(a1, pointer);
      if ( filetype == "MDX" ) {
        this._synth.loadMDX(pointer, data.byteLength);
        // Note: loadMDX internally frees the pointer, don't free here
        // Send title immediately after loading (before play)
        const titleData = {
          type: "TITLE",
          titleBytes: Array.from(this._synth.getTitleBytes())
        };
        this.port.postMessage(JSON.stringify(titleData));
      }
      if ( filetype == "PDX" ) {
        const AsciiStrToMem = function(p, s) {
          let i = 0;
          for (i = 0; i < s.length; i++) {
            Module.HEAP8[p + i] = s.charCodeAt(i)
          }
          Module.HEAP8[p+i] = 0x00;
        }
        let p1 = Module._malloc(256);
        AsciiStrToMem(p1, pdxfilename.toUpperCase());
        this._synth.loadPDX(pointer, data.byteLength, p1);
        Module._free(p1);
        // Note: loadPDX does NOT free pointer, so we need to free it here
        Module._free(pointer);
      }
      a1 = null;
    }


    //    const isDown = event.data;
    //    isDown ? this._synth.noteOn(60) : this._synth.noteOff(60);
    this.port.postMessage(str);
  }
}

registerProcessor('wasm-synth', SynthProcessor);
